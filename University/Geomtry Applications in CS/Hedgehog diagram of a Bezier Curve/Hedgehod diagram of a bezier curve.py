import bezier
import numpy as np
from matplotlib import pyplot as plt
import math


#Definition of the interval
noSubInterval = 50
a = 0.0
b = 1.0

#Value of each division (t)
T = np.arange(a, b, (b-a)/noSubInterval).tolist()

#Formula for r-combinations of n
def nCr(n, k):
    f = math.factorial
    return f(n) // f(k) // f(n - k)

#Bernstein polynomial
def bernstein(t, n, k):
    b = nCr(n, k) * (t ** k) * (1 - t) ** (n - k)
    return b


#Get a point on the bezier curve using t
def bezier_curve(P, t):
    n = len(P) - 1
    x_val = [x[0] for x in P]
    y_val = [x[1] for x in P]
    Rx = 0
    Ry = 0
    for k in range(0, n + 1):
        Rx = Rx + bernstein(t, n, k) * x_val[k]
        Ry = Ry + bernstein(t, n, k) * y_val[k]
    return Rx, Ry

#Will return a list of points from the bezier curve
def bezier_equation(P):
    Rx = []
    Ry = []
    for t in range(0, noSubInterval):
        x, y = bezier_curve(P, T[t])
        Rx.append(x)
        Ry.append(y)
    R = [Rx, Ry]
    return R


def readInput():
    n = int(input("Please enter the grade of the curve (no of points - 1): "))
    P = []
    for i in range(0, n+1):
        x = float(input("Please enter the x coordinate: "))
        y = float(input("Please enter the y coordinate: "))
        p0 = [x, y]
        P.append(p0)
    return P


#Because there is no easy way to implement a polynomial equation and then find it's derivative,
#This program will estimate the derivative in a point using 2 other points. After some trying,
#I found that the derivative coincided with the arithmetic mean of 2 slopes of lines that contain
#the given point and 2 other points from the curve
#After some research online, I found that this is the best possible estimate to the derivative in a point
#And it may be more efficient than implementing polynomials.
#Obs: Because the definition of the curvature will be divided in so many equal parts, the derivitave will be on spot
def estimate_derivative(P):
    dRx = []
    dRy = []

    Px = P[0] #x coords
    Py = P[1] #y coords
    n = len(Px) - 1

    #Slope of the line generated by the first and second point
    m1 = (Px[1]-Px[0])/(T[1]-T[0])
    #Slope of the line generated by the first and third point
    m2 = (Px[2]-Px[0])/(T[2]-T[0])
    #The estimate of the derivative is saved
    dRx.append((m1+m2)/2)

    #Repeat for y coordinate
    m1 = round((Py[1]-Py[0])/(T[1]-T[0]), 4)
    m2 = round((Py[2]-Py[0])/(T[2]-T[0]), 4)
    dRy.append((m1+m2)/2)

    for i in range(1, n):
        m1 = round((Px[i - 1]-Px[i])/(T[i - 1]-T[i]), 4)
        m2 = round((Px[i + 1]-Px[i])/(T[i + 1]-T[i]), 4)
        dRx.append((m1+m2)/2)

        m1 = round((Py[i - 1]-Py[i])/(T[i - 1]-T[i]), 4)
        m2 = round((Py[i + 1]-Py[i])/(T[i + 1]-T[i]), 4)
        dRy.append((m1+m2)/2)

    m1 = round((Px[n - 2]-Px[n])/(T[n - 2]-T[n]), 4)
    m2 = round((Px[n - 2]-Px[n])/(T[n - 1]-T[n]), 4)
    dRx.append((m1+m2)/2)

    m1 = round((Py[n - 2]-Py[n])/(T[n - 2]-T[n]), 4)
    m2 = round((Py[n - 2]-Py[n])/(T[n - 1]-T[n]), 4)
    dRy.append((m1+m2)/2)

    return [dRx, dRy]


#This function will return the values of the normal vector
def normal_vector(P):
    R = estimate_derivative(P)

    px = R[0]
    py = R[1]

    nx = []
    ny = []


    for i in range(0, len(px)):
        nx.append(-1 * py[i])
        ny.append(px[i])

    return [nx, ny]

def normal_versor(P):
    N = normal_vector(P)
    Nx = N[0]
    Ny = N[1]

    nx = []
    ny = []

    for i in range(0, len(Nx)):
        if (math.sqrt(Nx[i] ** 2 + Ny[i] ** 2) == 0.0):
            nx.append(0)
            ny.append(0)
        else:
            nx.append(Nx[i] / math.sqrt(Nx[i] ** 2 + Ny[i] ** 2))
            ny.append(Ny[i] / math.sqrt(Nx[i] ** 2 + Ny[i] ** 2))

    return [nx, ny]



def signed_curvature(P):
    R = bezier_equation(P)
    #r'(t)
    Rd = estimate_derivative(R)
    #r''(t)
    Rdd = estimate_derivative(Rd)

    #k+-(t)
    sK = []

    Rdx = Rd[0]
    Rdy = Rd[1]

    Rddx = Rdd[0]
    Rddy = Rdd[1]

    for i in range(0, len(Rdx)):
        k = (-1 * Rddx[i] * Rdy[i] + Rdx[i] * Rddy[i]) / (math.sqrt(Rdx[i] ** 2 + Rdy[i] ** 2)) ** 3
        sK.append(k)

    return sK

#The scale factor is s = 1/kmax, where k is the signed curvature in a point
def scale_factor(K):
    k = [abs(x) for x in K]
    kmax = max(k)
    s = 1/kmax * 0.1
    return s


#The vectors of 
def get_vectors(s, k, n):
    vx = []
    vy = []
    nx = n[0]
    ny = n[1]

    for i in range(0, len(nx)):
        vx.append(-1 * s * k[i] * nx[i])
        vy.append(-1 * s * k[i] * ny[i])

    return [vx, vy]


def plot_vectors(V, R):
    vx = V[0]
    vy = V[1]

    rx = R[0]
    ry = R[1]

    for i in range(0, len(vx)):
        plt.plot([rx[i], vx[i] + rx[i]], [ry[i], vy[i] + ry[i]], c="black")


def show_drawing(P):
    x = []
    y = []
    for i in range(0, len(P)):
        x.append(P[i][0])
        y.append(P[i][1])
    n = np.asfortranarray([x, y])
    c = bezier.Curve(n, degree=len(P) - 1)
    c.plot(num_pts=256)
    

def main():
    #P contains 2 lists: the x coords of the points and the y coords
    P = readInput()

    #R contains the same lists as P, but this time there are points from the bezier curve
    R = bezier_equation(P)

    #n contains a list of all the normal versors for t_i
    n = normal_versor(R)

    #K contains a list of the signed curvatures for t_i
    K = signed_curvature(P)

    #s is the scale factor
    s = scale_factor(K)
    
    #The position vectors given by -s*k(t_i) * n(t_i)
    V = get_vectors(s, K, n)

    plot_vectors(V, R)
    show_drawing(P)
    
    
    plt.show()

main()